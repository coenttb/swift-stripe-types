//
//  Stripe Billing Plans Types Billing Plans.swift
//  swift-stripe-types
//
//  Created by Coen ten Thije Boonkkamp on 13/01/2025.
//

import Foundation
import Stripe_Types_Models
import Stripe_Types_Shared

extension Stripe.Billing.Plans {
  // https://docs.stripe.com/api/plans/create.md
  public enum Create {}
}

extension Stripe.Billing.Plans.Create {
  public struct Request: Codable, Equatable, Sendable {
    public typealias ID = Tagged<Self, String>
    /// An identifier randomly generated by Stripe
    public var id: ID?
    /// Whether the plan is currently available for new subscriptions
    public var active: Bool?
    /// A positive integer in cents (or 0 for a free plan)
    public var amount: Int?
    /// Same as amount, but accepts a decimal value
    public var amountDecimal: String?
    /// Three-letter ISO currency code
    public var currency: Stripe.Currency
    /// Specifies billing frequency
    public var interval: Stripe.Billing.Plan.Interval
    /// The number of intervals between subscription billings
    public var intervalCount: Int?
    /// A brief description of the plan
    public var nickname: String?
    /// The product whose pricing this plan determines
    public var product: ProductReference?
    /// Configures how the quantity per period should be determined
    public var usageType: UsageType?
    /// Set of key-value pairs
    public var metadata: [String: String]?
    /// Define thresholds at which an invoice will be sent
    public var billingThresholds: BillingThresholds?
    /// Describes how to compute the price per period
    public var billingScheme: Stripe.Billing.Plan.BillingScheme?
    /// A positive integer in cents
    public var trialPeriodDays: Int?
    /// Tiers to use for this plan
    public var tiers: [Stripe.Billing.Plan.Tier]?
    /// Specifies which mode to use for tiers
    public var tiersMode: Stripe.Billing.Plan.TiersMode?
    /// Apply a transformation to the reported usage
    public var transformUsage: Stripe.Billing.Plan.TransformUsage?

    public init(
      id: ID? = nil,
      active: Bool? = nil,
      amount: Int? = nil,
      amountDecimal: String? = nil,
      currency: Stripe.Currency,
      interval: Stripe.Billing.Plan.Interval,
      intervalCount: Int? = nil,
      nickname: String? = nil,
      product: ProductReference? = nil,
      usageType: UsageType? = nil,
      metadata: [String: String]? = nil,
      billingThresholds: BillingThresholds? = nil,
      billingScheme: Stripe.Billing.Plan.BillingScheme? = nil,
      trialPeriodDays: Int? = nil,
      tiers: [Stripe.Billing.Plan.Tier]? = nil,
      tiersMode: Stripe.Billing.Plan.TiersMode? = nil,
      transformUsage: Stripe.Billing.Plan.TransformUsage? = nil
    ) {
      self.id = id
      self.active = active
      self.amount = amount
      self.amountDecimal = amountDecimal
      self.currency = currency
      self.interval = interval
      self.intervalCount = intervalCount
      self.nickname = nickname
      self.product = product
      self.usageType = usageType
      self.metadata = metadata
      self.billingThresholds = billingThresholds
      self.billingScheme = billingScheme
      self.trialPeriodDays = trialPeriodDays
      self.tiers = tiers
      self.tiersMode = tiersMode
      self.transformUsage = transformUsage
    }

    private enum CodingKeys: String, CodingKey {
      case id
      case active
      case amount
      case amountDecimal = "amount_decimal"
      case currency
      case interval
      case intervalCount = "interval_count"
      case nickname
      case product
      case usageType = "usage_type"
      case metadata
      case billingThresholds = "billing_thresholds"
      case billingScheme = "billing_scheme"
      case trialPeriodDays = "trial_period_days"
      case tiers
      case tiersMode = "tiers_mode"
      case transformUsage = "transform_usage"
    }
  }

  public enum ProductReference: Codable, Equatable, Sendable {
    case id(String)
    case data(ProductData)

    public func encode(to encoder: Encoder) throws {
      var container = encoder.singleValueContainer()
      switch self {
      case .id(let id):
        try container.encode(id)
      case .data(let data):
        try container.encode(data)
      }
    }

    public init(from decoder: Decoder) throws {
      let container = try decoder.singleValueContainer()
      if let id = try? container.decode(String.self) {
        self = .id(id)
      } else if let data = try? container.decode(ProductData.self) {
        self = .data(data)
      } else {
        throw DecodingError.dataCorruptedError(
          in: container,
          debugDescription: "Invalid ProductReference"
        )
      }
    }
  }

  public struct ProductData: Codable, Equatable, Sendable {
    /// The product's name
    public var name: String
    /// An arbitrary string to be displayed on your customer's credit card statement
    public var statementDescriptor: String?
    /// Whether the product is currently available for purchase
    public var active: Bool?
    /// Set of key-value pairs
    public var metadata: [String: String]?

    public init(
      name: String,
      statementDescriptor: String? = nil,
      active: Bool? = nil,
      metadata: [String: String]? = nil
    ) {
      self.name = name
      self.statementDescriptor = statementDescriptor
      self.active = active
      self.metadata = metadata
    }

    private enum CodingKeys: String, CodingKey {
      case name
      case statementDescriptor = "statement_descriptor"
      case active
      case metadata
    }
  }

  public enum UsageType: String, Codable, Equatable, Sendable {
    case metered
    case licensed
  }

  public struct BillingThresholds: Codable, Equatable, Sendable {
    /// Usage threshold
    public var usageGte: Int?

    public init(usageGte: Int? = nil) {
      self.usageGte = usageGte
    }

    private enum CodingKeys: String, CodingKey {
      case usageGte = "usage_gte"
    }
  }

  public enum BillingScheme: String, Codable, Equatable, Sendable {
    case perUnit = "per_unit"
    case tiered
  }

  public struct Tier: Codable, Equatable, Sendable {
    /// Per unit price for units relevant to the tier
    public var unitAmount: Int?
    /// Same as unit_amount, but accepts a decimal value
    public var unitAmountDecimal: String?
    /// Price for the entire tier
    public var flatAmount: Int?
    /// Same as flat_amount, but accepts a decimal value
    public var flatAmountDecimal: String?
    /// Up to and including to this quantity will be contained in the tier
    public var upTo: UpTo?

    public init(
      unitAmount: Int? = nil,
      unitAmountDecimal: String? = nil,
      flatAmount: Int? = nil,
      flatAmountDecimal: String? = nil,
      upTo: UpTo? = nil
    ) {
      self.unitAmount = unitAmount
      self.unitAmountDecimal = unitAmountDecimal
      self.flatAmount = flatAmount
      self.flatAmountDecimal = flatAmountDecimal
      self.upTo = upTo
    }

    private enum CodingKeys: String, CodingKey {
      case unitAmount = "unit_amount"
      case unitAmountDecimal = "unit_amount_decimal"
      case flatAmount = "flat_amount"
      case flatAmountDecimal = "flat_amount_decimal"
      case upTo = "up_to"
    }
  }

  public enum UpTo: Codable, Equatable, Sendable {
    case inf
    case value(Int)

    public func encode(to encoder: Encoder) throws {
      var container = encoder.singleValueContainer()
      switch self {
      case .inf:
        try container.encode("inf")
      case .value(let value):
        try container.encode(value)
      }
    }

    public init(from decoder: Decoder) throws {
      let container = try decoder.singleValueContainer()
      if let string = try? container.decode(String.self), string == "inf" {
        self = .inf
      } else if let value = try? container.decode(Int.self) {
        self = .value(value)
      } else {
        throw DecodingError.dataCorruptedError(
          in: container,
          debugDescription: "Invalid UpTo value"
        )
      }
    }
  }

  public enum TiersMode: String, Codable, Equatable, Sendable {
    case graduated
    case volume
  }

  public struct TransformUsage: Codable, Equatable, Sendable {
    /// Divide usage by this number
    public var divideBy: Int
    /// After division, either round up or down
    public var round: Round

    public init(divideBy: Int, round: Round) {
      self.divideBy = divideBy
      self.round = round
    }

    private enum CodingKeys: String, CodingKey {
      case divideBy = "divide_by"
      case round
    }
  }

  public enum Round: String, Codable, Equatable, Sendable {
    case up
    case down
  }
}

extension Stripe.Billing.Plans {
  // https://docs.stripe.com/api/plans/update.md
  public enum Update {}
}

extension Stripe.Billing.Plans.Update {
  public struct Request: Codable, Equatable, Sendable {
    /// Whether the plan is currently available for new subscriptions
    public var active: Bool?
    /// A brief description of the plan
    public var nickname: String?
    /// Set of key-value pairs
    public var metadata: [String: String]?
    /// The product the plan belongs to
    public var product: Stripe.Products.Product.ID?
    /// Default number of trial days when subscribing a customer
    public var trialPeriodDays: Int?

    public init(
      active: Bool? = nil,
      nickname: String? = nil,
      metadata: [String: String]? = nil,
      product: Stripe.Products.Product.ID? = nil,
      trialPeriodDays: Int? = nil
    ) {
      self.active = active
      self.nickname = nickname
      self.metadata = metadata
      self.product = product
      self.trialPeriodDays = trialPeriodDays
    }

    private enum CodingKeys: String, CodingKey {
      case active
      case nickname
      case metadata
      case product
      case trialPeriodDays = "trial_period_days"
    }
  }
}

extension Stripe.Billing.Plans {
  // https://docs.stripe.com/api/plans/list.md
  public enum List {}
}

extension Stripe.Billing.Plans.List {
  public struct Request: Codable, Equatable, Sendable {
    /// Only return plans that are active or not active
    public var active: Bool?
    /// Filter by creation date
    public var created: Stripe.DateFilter?
    /// Pagination cursor
    public var endingBefore: String?
    /// Number of objects to return
    public var limit: Int?
    /// Only return plans for the given product
    public var product: Stripe.Products.Product.ID?
    /// Pagination cursor
    public var startingAfter: String?

    public init(
      active: Bool? = nil,
      created: Stripe.DateFilter? = nil,
      endingBefore: String? = nil,
      limit: Int? = nil,
      product: Stripe.Products.Product.ID? = nil,
      startingAfter: String? = nil
    ) {
      self.active = active
      self.created = created
      self.endingBefore = endingBefore
      self.limit = limit
      self.product = product
      self.startingAfter = startingAfter
    }

    private enum CodingKeys: String, CodingKey {
      case active
      case created
      case endingBefore = "ending_before"
      case limit
      case product
      case startingAfter = "starting_after"
    }
  }

  public struct Response: Codable, Sendable {
    public let object: String
    public let url: String
    public let hasMore: Bool
    public let data: [Stripe.Billing.Plan]

    private enum CodingKeys: String, CodingKey {
      case object
      case url
      case hasMore = "has_more"
      case data
    }
  }
}
